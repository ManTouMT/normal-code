# 锁
我这里总结下， MySQL行级锁的加锁规则。
唯一索引等值查询:
- 当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会
退化成「记录锁」。
- 当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的
next-key lock 会退化成「间隙锁」。

非唯一索引等值查询:
- 当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是非唯一索引等值
查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描
的过程中，对扫描到的二级索引记录加的是 next-key 锁，而对于第一个不符合条件的二级索引记录
该二级索引的 next-key 锁会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁。
- 当查询的记录「不存在」时，扫描到第一条不符合条件的二级索引记录，该二级索引的 next-key 锁会
退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁，

非唯一索引和主键索引的范围查询的加锁规则不同之处在于:
唯一索引在满足一些条件的时候，索引的 next-key lock 退化为间隙锁或者记录锁。
非唯一索引范围查询，索引的 next-key lock 不会退化为间隙锁和记录锁。

其实理解 MVSQL为什么要这样加锁，主要要以避免幻读角度去分析，这样就很容易理解这些加锁的规则
还有一件很重要的事情，在线上在执行 update、delete、select. for update 等具有加锁性质的语句，
定要检查语句是否走了索引，如果是全表扫描的话， 会对每一个索引加 next-key 锁，相当于把整个表锁
这是挺严重的问题。

锁并不是执行完 update 语句就会释放的，而是会等事务结束时才会释放。

在 InnoD8 事务中，对记录加锁带基本单位是 next-key 锁，但是会因为一些条件会退化成间隙锁，或者记
录锁。加锁的位置准确的说，锁是加在索引上的而非行上。

锁是在遍历索引的时候加上的，并不是针对输出的结果加锁。
因此，在线上在执行 update、delete、select .. for update 等具有加锁性质的语句，一定要检查语句是否
走了索引，如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了，这是挺严重
的问题。